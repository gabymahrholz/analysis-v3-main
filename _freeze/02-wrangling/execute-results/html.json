{
  "hash": "fe2263dcf1e66ef35c80a39e1a337a03",
  "result": {
    "markdown": "# Data wrangling I {#sec-wrangling}\n\n## Intended Learning Outcomes {.unnumbered}\n\nIn the next two chapters, we will build on the data wrangling skills from level 1. We will revisit all the functions you have already encountered (and might have forgotten over the summer break) and introduce 2 or 3 new functions. These two chapters will provide an opportunity to revise and apply the functions to a novel dataset.\n\nBy the end of this chapter, you should be able to:\n\n-   apply familiar data wrangling functions to novel datasets\n-   read and interpret error messages\n-   realise there are several ways of getting to the results \n-   export data objects as csv files\n\n\nThe main purpose of this chapter and @sec-wrangling2 is to wrangle your data into shape for data visualisation (@sec-dataviz and @sec-dataviz2). For the two chapters, we will: \n\n1. calculate demographics\n2. tidy 3 different questionnaires with varying degrees of complexity\n3. solve an error mode problem\n4. join all data objects together\n\n## [Individual Walkthrough]{style=\"color: #F39C12; text-transform: uppercase;\"} {.unnumbered}\n\nBefore we start, we need to set up some things.\n\n## Activity 1: Setup\n\n* We will be working on the **dataset by Pownall et al. (2023)** again, which means we can still use the project we created last week. The data files will already be there, so no need to download them again.\n* To **open the project** in RStudio, go to the folder in which you stored the project and the data last time, and double click on the project icon.\n* **Create a new `.Rmd` file** for chapter 2 and save it to your project folder. Name it something meaningful (e.g., ‚Äúchapter_02.Rmd‚Äù, ‚Äú02_data_wrangling.Rmd‚Äù). See @sec-rmd if you need some guidance.\n* In your newly created `.Rmd` file, delete everything below line 12 (after the set-up code chunk).\n\n\n## Activity 2: Load in the libraries and read in the data\n\nWe will use `tidyverse` today, and we want to create a data object `data_prp` that stores the data from the file `prp_data_reduced.csv`.\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n\n## Hint\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(???)\ndata_prp <- read_csv(\"???\")\n```\n:::\n\n\n\n\n:::\n\n\n::: {.callout-caution collapse=\"true\" icon=\"false\"} \n\n## Solution \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ndata_prp <- read_csv(\"prp_data_reduced.csv\")\n```\n:::\n\n\n:::\n\nIf you need a quick reminder what the dataset was about, have a look at the abstract in @sec-download_data_ch1. We also addressed the changes we made to the dataset there.\n\nAnd remember to have a quick `glimpse()` at your data. \n\n\n\n## Activity 3: Calculating demographics \n\n\nLet‚Äôs start with some simple data wrangling steps to compute demographics for our original dataset, `data_prp`. First, we want to determine how many participants took part in the study by Pownall et al. (2023) and compute the mean age and the standard deviation of age for the sample.\n\n### ... for the full sample using `summarise()`\n\nThe `summarise()` function is part of the **\"Wickham 6\"** alongside `group_by()`, `select()`, `filter()`, `mutate()`, and `arrange()`. You used them plenty of times last year.\n\nWithin `summarise()`, we can use the `n()` function, which calculates the number of rows in the dataset. Since each row corresponds to a unique participant, this gives us the total number of participants.\n\nTo calculate the mean age and the standard deviation of age, we need to use the functions `mean()` and `sd()` on the column `Age` respectively.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndemo_total <- data_prp %>% \n  summarise(n = n(), # participant number\n            mean_age = mean(Age), # mean age\n            sd_age = sd(Age)) # standard deviation of age\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: There were 2 warnings in `summarise()`.\nThe first warning was:\n‚Ñπ In argument: `mean_age = mean(Age)`.\nCaused by warning in `mean.default()`:\n! argument is not numeric or logical: returning NA\n‚Ñπ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n```\n:::\n\n```{.r .cell-code}\ndemo_total\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|  n| mean_age| sd_age|\n|--:|--------:|------:|\n| 89|       NA|     NA|\n\n</div>\n:::\n:::\n\n\nR did not give us an error message per se, but the output is not quite as expected either. There are `NA` values in the `mean_age` and `sd_age` columns. Looking at the warning message and at `Age`, can you explain what happened?\n\n::: {.callout-caution collapse=\"true\" icon=\"false\"} \n\n## Answer\n\nThe warning message says: `argument is not numeric or logical: returning NA` If we look at the `Age` column more closely, we can see that it's a character data type.\n\n:::\n\n#### Fixing `Age` {.unnumbered}\n\nMight be wise to look at the unique answers in column `Age` to determine what is wrong. We can do that with the function `distinct()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nage_distinct <- data_prp %>% \n  distinct(Age)\n\nage_distinct\n```\n:::\n\n\n\n::: {.callout-caution collapse=\"true\" icon=\"false\"}\n\n## Show the unique values of `Age`.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|Age      |\n|:--------|\n|22       |\n|20       |\n|26       |\n|21       |\n|29       |\n|23       |\n|39       |\n|NA       |\n|24       |\n|43       |\n|31       |\n|25 years |\n\n</div>\n:::\n:::\n\n\n:::\n\n::: {.columns}\n\n::: {.column}\n\nOne cell has the string \"years\" added to their number 25, which has converted the entire column into a character column. \n\nWe can easily fix this by extracting only the numbers from the column and converting it into a numeric data type. The `parse_number()` function, which is part of the `tidyverse` package, handles both steps in one go (so there‚Äôs no need to load additional packages).\n\nWe will combine this with the `mutate()` function to create a new column called `Age` (containing those numeric values), effectively replacing the old `Age` column (which had the character values).\n\n:::\n\n\n::: {.column}\n\n![parse_number() illustration by Allison Horst (see [https://allisonhorst.com/r-packages-functions](https://allisonhorst.com/r-packages-functions){target=\"_blank\"})](images/parse_number.png){width=\"95%\"}\n\n:::\n\n:::\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata_prp <- data_prp %>% \n  mutate(Age = parse_number(Age))\n\ntypeof(data_prp$Age) # fixed\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n#### Computing summary stats {.unnumbered}\n\nExcellent. Now that the numbers are in a numeric format, let's try calculating the demographics for the total sample again.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndemo_total <- data_prp %>% \n  summarise(n = n(), # participant number\n            mean_age = mean(Age), # mean age\n            sd_age = sd(Age)) # standard deviation of age\n\ndemo_total\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|  n| mean_age| sd_age|\n|--:|--------:|------:|\n| 89|       NA|     NA|\n\n</div>\n:::\n:::\n\n\nEven though there's no error or warning, the table still shows `NA` values for `mean_age` and `sd_age`. So, what could possibly be wrong now?\n\n::: {.callout-caution collapse=\"true\" icon=\"false\"} \n\n## Answer\n\nDid you notice that the `Age` column in `age_distinct` contains some missing values (`NA`)? To be honest, it's easier to spot this issue in the actual R output than in the printed HTML page.\n\n:::\n\n\n#### Computing summary stats - third attempt {.unnumbered}\n\nTo ensure R ignores missing values during calculations, we need to add the extra argument `na.rm = TRUE` to the `mean()` and `sd()` functions.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndemo_total <- data_prp %>% \n  summarise(n = n(), # participant number\n            mean_age = mean(Age, na.rm = TRUE), # mean age\n            sd_age = sd(Age, na.rm = TRUE)) # standard deviation of age\n\ndemo_total\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|  n| mean_age|   sd_age|\n|--:|--------:|--------:|\n| 89| 21.88506| 3.485603|\n\n</div>\n:::\n:::\n\n\nFinally, we‚Äôve got it! ü•≥ Third time's the charm!\n\n\n### ... per gender using `summarise()` and `group_by()`\n\nNow we want to compute the summary statistics for each gender. The code inside the `summarise()` function remains unchanged; we just need to use the `group_by()` function beforehand to tell R that we want to compute the summary statistics for each group separately. It‚Äôs also a good practice to use `ungroup()` afterwards, so you are not taking groupings forward unintentionally.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndemo_by_gender <- data_prp %>% \n  group_by(Gender) %>% # split data up into groups (here Gender)\n  summarise(n = n(), # participant number \n            mean_age = mean(Age, na.rm = TRUE), # mean age \n            sd_age = sd(Age, na.rm = TRUE)) %>%  # standard deviation of age\n  ungroup()\n\ndemo_by_gender\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| Gender|  n| mean_age|   sd_age|\n|------:|--:|--------:|--------:|\n|      1| 17| 23.31250| 5.770254|\n|      2| 69| 21.57353| 2.738973|\n|      3|  3| 21.33333| 1.154700|\n\n</div>\n:::\n:::\n\n\n\n### Adding percentages \n\nSometimes, it may be useful to calculate percentages, such as for the gender split. You can do this by adding a line within the `summarise()` function to perform the calculation. All we need to do is take the number of female, male, and non-binary participants (stored in the `n` column of `demo_by_gender`), divide it by the total number of participants (stored in the `n` column of `demo_total`), and multiply by 100. Let's add `percentage` to the `summarise()` function of `demo_by_gender`. Make sure that the code for `percentages` is placed after the value for `n` has been computed. \n\nAccessing the value of `n` for the different gender categories is straightforward because we can refer back to it directly. However, since the total number of participants is stored in a different data object, we need to use a base R function to access it ‚Äì specifically the `$` operator. To do this, you simply type the name of the data object (in this case, `demo_total`), followed by the `$` symbol (with no spaces), and then the name of the column you want to retrieve (in this case, `n`). The general pattern is `data$column`.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndemo_by_gender <- data_prp %>% \n  group_by(Gender) %>% \n  summarise(n = n(), \n            # n from the line above divided by n from demo_total *100\n            percentage = n/demo_total$n *100, \n            mean_age = mean(Age, na.rm = TRUE), \n            sd_age = sd(Age, na.rm = TRUE)) %>% \n  ungroup()\n\ndemo_by_gender\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| Gender|  n| percentage| mean_age|   sd_age|\n|------:|--:|----------:|--------:|--------:|\n|      1| 17|  19.101124| 23.31250| 5.770254|\n|      2| 69|  77.528090| 21.57353| 2.738973|\n|      3|  3|   3.370786| 21.33333| 1.154700|\n\n</div>\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n\n## Tip for decimal places - use `round()`\n\nNot super important, because you could round the values by yourself when writing up your reports, but if you wanted to tidy up the decimal places in the output, you can do that using the `round()` function. You would need to \"wrap\" it around your computations and specify how many decimal places you want to display (for example `mean(Age)` would turn into `round(mean(Age), 1)`). It may look odd for `percentage`, just make sure the number that specifies the decimal places is placed **within** the round function. The default value is 0 (meaning no decimal spaces).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndemo_by_gender <- data_prp %>% \n  group_by(Gender) %>% \n  summarise(n = n(), \n            percentage = round(n/demo_total$n *100, 2), # percentage with 2 decimal places\n            mean_age = round(mean(Age, na.rm = TRUE), 1), # mean Age with 1 decimal place\n            sd_age = round(sd(Age, na.rm = TRUE), 3)) %>% # sd Age with 3 decimal places\n  ungroup()\n\ndemo_by_gender\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| Gender|  n| percentage| mean_age| sd_age|\n|------:|--:|----------:|--------:|------:|\n|      1| 17|      19.10|     23.3|  5.770|\n|      2| 69|      77.53|     21.6|  2.739|\n|      3|  3|       3.37|     21.3|  1.155|\n\n</div>\n:::\n:::\n\n\n:::\n\n\n## Activity 4: Questionable Research Practices (QRPs) {#sec-ch2_act4}\n\n#### The main goal is to compute the mean QRP score per participant for time point 1. {.unnumbered}\n\nLooking at the QRP data at time point 1, you determine that\n\n* individual item columns are <select class='webex-select'><option value='blank'></option><option value='answer'>numeric</option><option value='x'>character</option></select>, and \n* according to the codebook, there are <select class='webex-select'><option value='blank'></option><option value='answer'>no</option><option value='x'>some</option></select> reverse-coded items in this questionnaire. \n\nSo, we just have to **compute an average score for items 1 to 11** as items 12 to 15 are distractor items. Seems quite straightforward.\n\nThe downside is that individual items are each in a separate column, i.e., in **wide format**, and everything would be easier if the items were arranged in **long format**.\n\nLet's tackle this problem in steps. Best would be to create a separate data object for that. If we wanted to compute this within `data_prp`, it would turn into a nightmare.\n\n* **Step 1**: select the relevant columns `Code`, and `QRPs_1_Time1` to `QRPs_1_Time1` and store them in an object called `qrp_t1`\n* **Step 2**: pivot the data from wide format to long format using `pivot_longer()` so we can calculate the average score more easily (in step 3)\n* **Step 3**: calculate the average QRP score (`QRPs_Acceptance_Time1_mean`) per participant using `group_by()` and `summarise()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nqrp_t1 <- data_prp %>% \n  #Step 1\n  select(Code, QRPs_1_Time1:QRPs_11_Time1) %>%\n  # Step 2\n  pivot_longer(cols = -Code, names_to = \"Items\", values_to = \"Scores\") %>% \n  # Step 3\n  group_by(Code) %>% # grouping py participant id\n  summarise(QRPs_Acceptance_Time1_mean = mean(Scores)) %>% # calculating the average Score\n  ungroup() # just make it a habit\n```\n:::\n\n\n\n::: {.callout-caution icon=\"false\" collapse=\"true\"} \n\n## Explain the individual functions\n\n::: {.panel-tabset}\n## `select ()`\n\nThe select function allows to include or exclude certain variables (columns). Here we want to focus on the participant ID column (i.e., `Code`) and the QRP items at time point 1. We can either list them all individually, i.e., Code, QRPs_1_Time1, QRPs_2_Time1, QRPs_3_Time1, and so forth (you get the gist), but that would take forever to type. \n\nA shortcut is to use the colon operator `:`. It allows us to select all columns that fall within the range of `first_column_name` to `last_column_name`. We can apply this here since the QRP items (1 to 11) are sequentially listed in `data_prp`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nqrp_step1 <- data_prp %>% \n  select(Code, QRPs_1_Time1:QRPs_11_Time1)\n\n# show first 5 rows of qrp_step1\nhead(qrp_step1, n = 5)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|Code | QRPs_1_Time1| QRPs_2_Time1| QRPs_3_Time1| QRPs_4_Time1| QRPs_5_Time1| QRPs_6_Time1| QRPs_7_Time1| QRPs_8_Time1| QRPs_9_Time1| QRPs_10_Time1| QRPs_11_Time1|\n|:----|------------:|------------:|------------:|------------:|------------:|------------:|------------:|------------:|------------:|-------------:|-------------:|\n|Tr10 |            7|            7|            5|            7|            3|            4|            5|            7|            6|             7|             7|\n|Bi07 |            7|            7|            2|            7|            3|            7|            7|            7|            7|             6|             7|\n|SK03 |            7|            7|            6|            6|            7|            6|            7|            7|            7|             5|             7|\n|SM95 |            7|            7|            2|            6|            7|            5|            7|            7|            4|             2|             4|\n|St01 |            7|            7|            6|            7|            2|            7|            7|            7|            7|             5|             7|\n\n</div>\n:::\n:::\n\n\nHow many rows/observations and columns/variables do we have in `qrp_step1`?\n\n* rows/observations: <input class='webex-solveme nospaces' size='2' data-answer='[\"89\"]'/>\n* columns/variables: <input class='webex-solveme nospaces' size='2' data-answer='[\"12\"]'/>\n\n\n\n## `pivot_longer()`\n\nAs you can see, the table we got from Step 1 is in wide format. To get it into wide format, we need to define:\n\n* the columns that need to be reshuffled from wide into long format (`col` argument). Here we selected \"everything except the `Code` column\", as indicated by `-Code` [minus `Code`]. However, `QRPs_1_Time1:QRPs_11_Time1` would also work and give you the exact same result.\n* the `names_to` argument. R is creating a new column in which all the column names from the columns you selected in `col` will be stored in. Here we are naming this column \"Items\" but you could pick something equally sensible if you like.\n* the `values_to` argument. R creates this second column to store all responses the participants gave to the individual questions, i.e., all the numbers in this case. We named it \"Scores\" here, but you could have called it something different, like \"Responses\"\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nqrp_step2 <- qrp_step1 %>% \n  pivot_longer(cols = -Code, names_to = \"Items\", values_to = \"Scores\")\n\n# show first 15 rows of qrp_step2\nhead(qrp_step2, n = 15)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|Code |Items         | Scores|\n|:----|:-------------|------:|\n|Tr10 |QRPs_1_Time1  |      7|\n|Tr10 |QRPs_2_Time1  |      7|\n|Tr10 |QRPs_3_Time1  |      5|\n|Tr10 |QRPs_4_Time1  |      7|\n|Tr10 |QRPs_5_Time1  |      3|\n|Tr10 |QRPs_6_Time1  |      4|\n|Tr10 |QRPs_7_Time1  |      5|\n|Tr10 |QRPs_8_Time1  |      7|\n|Tr10 |QRPs_9_Time1  |      6|\n|Tr10 |QRPs_10_Time1 |      7|\n|Tr10 |QRPs_11_Time1 |      7|\n|Bi07 |QRPs_1_Time1  |      7|\n|Bi07 |QRPs_2_Time1  |      7|\n|Bi07 |QRPs_3_Time1  |      2|\n|Bi07 |QRPs_4_Time1  |      7|\n\n</div>\n:::\n:::\n\n\nNow, have a look at `qrp_step2`. In total, we now have <input class='webex-solveme nospaces' size='3' data-answer='[\"979\"]'/> rows/observations, <input class='webex-solveme nospaces' size='2' data-answer='[\"11\"]'/> per participant, and <input class='webex-solveme nospaces' size='1' data-answer='[\"3\"]'/> columns/variables.\n\n\n## `group_by()` and `summarise()`\n\nThis follows exactly the same sequence we used when calculating descriptive statistics by gender. The only difference is that we are now grouping the data by the participant's `Code` instead of `Gender`.\n\n`summarise()` works exactly the same way: \n`summarise(new_column_name = function_to_calculate_something(column_name_of_numeric_values))`\n\nThe `function_to_calculate_something` can be `mean()`, `sd()` or `sum()` for mean scores, standard deviations, or summed-up scores respectively. You could also use `min()` or `max()` if you wanted to determine the lowest or the highest score for each participant.\n\n:::\n\n:::\n\n\n::: {.callout-tip} \n\nYou could **rename the columns whilst selecting** them. The pattern would be `select(new_name = old_name)`. For example, if we wanted to select variable `Code` and rename it as `Participant_ID`, we could do that.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrenaming_col <- data_prp %>% \n  select(Participant_ID = Code)\n\nhead(renaming_col, n = 5)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|Participant_ID |\n|:--------------|\n|Tr10           |\n|Bi07           |\n|SK03           |\n|SM95           |\n|St01           |\n\n</div>\n:::\n:::\n\n\n\n:::\n\n\n## Activity 5: Knitting\n\nOnce you've completed your R Markdown file, the final step is to \"knit\" it, which converts the `.Rmd` file into a HTML file. Knitting combines your code, text, and output (like tables and plots) into a single cohesive document. This is a really good way to check your code is working.\n\nTo knit the file, **click the Knit button** at the top of your RStudio window. The document will be generated and, depending on your setting, automatically opened in the viewer in the `Output pane` or an external browser window.\n\nIf any errors occur during knitting, RStudio will show you an error message with details to help you troubleshoot.\n\nIf you want to **intentionally keep any errors** we tackled today to keep a reference on how you solved them, you could add `error=TRUE` or `eval=FALSE` to the code chunk that isn't running.\n\n\n## Activity 6: Export a data object as a csv\n\nTo avoid having to repeat the same steps in the next chapter, it's a good idea to save the data objects you've created today as csv files. You can do this by using the `write_csv()` function from the `readr` package. The csv files will appear in your project folder.\n\nThe basic syntax is:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwrite_csv(data_object, \"filename.csv\")\n```\n:::\n\n\n\nNow, let's export the objects `data_prp` and `qrp_t1`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwrite_csv(data_prp, \"data_prp_for_ch3.csv\")\n```\n:::\n\n\nHere we named the file `data_prp_for_ch3.csv`, so we wouldn't override the original data csv file `prp_data_reduced.csv`. However, feel free to choose a name that makes sense to you.\n\n::: {.callout-note icon=\"false\"} \n\n## Your Turn\n\nExport `qrp_t1`.\n\n::: {.callout-caution collapse=\"true\" icon=\"false\"} \n\n## Solution\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwrite_csv(qrp_t1, \"qrp_t1.csv\")\n```\n:::\n\n\n\n:::\n\n:::\n\n\nCheck that your csv files have appeared in your project folder, and you're all set!\n\n**That‚Äôs it for Chapter 2: Individual Walkthrough.**\n\n\n## [Pair-coding]{style=\"color: #F39C12; text-transform: uppercase;\"} {.unnumbered}\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\nWe will be working with the data from Binfet et al. (2021) again - the randomised controlled trial data about therapy dog intervention. Today we want to **calculate an average `Flourishing` score for each participant** measured at time point 1 (pre-intervention) from the raw data file `dog_data_raw`. Currently, it looks like this:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| RID| F1_1| F1_2| F1_3| F1_4| F1_5| F1_6| F1_7| F1_8|\n|---:|----:|----:|----:|----:|----:|----:|----:|----:|\n|   1|    6|    7|    5|    5|    7|    7|    6|    6|\n|   2|    5|    7|    6|    5|    5|    5|    5|    4|\n|   3|    5|    5|    5|    6|    6|    6|    5|    5|\n|   4|    7|    6|    7|    7|    7|    6|    7|    4|\n|   5|    5|    5|    4|    6|    7|    7|    7|    6|\n\n</div>\n:::\n:::\n\n\n\nBut we want to have the data looking like this:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| RID| Flourishing_pre|\n|---:|---------------:|\n|   1|           6.125|\n|   2|           5.250|\n|   3|           5.375|\n|   4|           6.375|\n|   5|           5.875|\n\n</div>\n:::\n:::\n\n\n\n### Task 1: Open the R project you created last week {.unnumbered}\n\nIf you haven't created an R project for the lab yet, please do it now. If you have already one in place, open it.\n\n### Task 2: Open your `.Rmd` file from last week {.unnumbered}\n\nSince we haven't used it much, feel free to use the `.Rmd` file you created last week in Task 2. \n\n### Task 3: Load in the library and read in the data {.unnumbered}\n\nThe data should be in your project folder. If you did not download it last week, or you want a fresh copy, you can download the data again here: [data_pair_ch1](data/data_pair_ch1.zip \"download\").\n\nWe are using the package `tidyverse` today, and the datafile we should read in is `dog_data_raw.csv`.\n\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n\n## Hint\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# loading tidyverse into the library\nlibrary(???)\n\n# reading in `dog_data_raw.csv`\ndog_data_raw <- read_csv(\"???\")\n```\n:::\n\n\n\n:::\n\n\n### Task 4: Calculating the mean for `Fourishing_pre` {.unnumbered}\n\n* **Step 1**: select all relevant columns, such as participant ID and all the 8 items of the `Flourishing` questionnaire that participants completed before the intervention. Store them in an object called `data_flourishing`\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n\n## Hint\n\nLook at the codebook. Try to figure out \n\n* the variable name of the column in which the participant id is stored, and \n* which items relate to the Flourishing scale at Stage `pre` \n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n\n## More concrete hint\n\n* the participant id column is called `RID` \n* The Flourishing items at pre-intervention stage start with `F1_`\n\n:::\n\n:::\n\n\n* **Step 2**: pivot the data from wide format to long format so we can calculate the average score more easily (in step 3)\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n\n## Hint\n\nWhich pivot function do we need? We have `pivot_wider()` and `pivot_longer()` to choose from.\n\nWe also need 3 arguments in that function: \n\n* the columns we want to select (e.g., all the flourishing items), \n* the name of the column in which the current column headings will be stored (e.g., \"Questionnaire\"), and \n* the name of the column that should store all the values (e.g., \"Responses\").\n\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n\n## More concrete hint\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n  pivot_longer(cols = ???, names_to = \"???\", values_to = \"???\")\n```\n:::\n\n\n\n:::\n\n:::\n\n\n* **Step 3**: calculate the average Flourishing score per participant. To match with the table above, we want to call this column `Flourishing_pre`\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n\n## Hint\n\nBefore we can summarise the mean, perhaps we need to group the data?\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n\n## More concrete hint\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n  group_by(???) %>% \n  summarise(Flourishing_pre = ???(???)) %>% \n  ungroup()\n```\n:::\n\n\n:::\n\n:::\n\n::: {.callout-caution collapse=\"true\" icon=\"false\"}\n\n## Solution\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# loading tidyverse into the library\nlibrary(tidyverse)\n\n# reading in `dog_data_raw.csv`\ndog_data_raw <- read_csv(\"dog_data_raw.csv\")\n\n# Task 4: Tidying \ndata_flourishing <- dog_data_raw %>% \n  # Step 1\n  select(RID, F1_1:F1_8) %>% \n  # Step 2\n  pivot_longer(cols = -RID, names_to = \"Questionnaire\", values_to = \"Responses\") %>% \n  # Step 3\n  group_by(RID) %>% \n  summarise(Flourishing_pre = mean(Response)) %>% \n  ungroup()\n```\n:::\n\n\n:::\n\n\n\n\n## [Test your knowledge and challenge yourself]{style=\"color: #F39C12; text-transform: uppercase;\"} {.unnumbered}\n\n\n**include a few mcq items here**\n\n\nIf you want to **challenge yourself** and apply the skills from chapter 2 further, you could wrangle the data from `dog_data_raw` for some of the other questionnaires _pre and/or _post intervention:\n\n* the mean score for `flourishing_post` for each participant\n* the mean scores for the PANAS - Positive and/or negative affect item per participant \n* the mean score for the happiness (SHS) item responses per participant\n\nThe 3 steps are equivalent for those questionnaires - select, pivot, group_by and summarise; you just have to \"replace\" the questionnaire items involved.\n\n::: {.callout-caution collapse=\"true\" icon=\"false\"}\n\n## Solution for **Challenge yourself**\n\nFlourishing post-intervention\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## flourishing_post\nflourishing_post <- dog_data_raw %>% \n  # Step 1\n  select(RID, starts_with(\"F2\")) %>% \n  # Step 2\n  pivot_longer(cols = -RID, names_to = \"Names\", values_to = \"Response\") %>% \n  # Step 3\n  group_by(RID) %>% \n  summarise(Flourishing_post = mean(Response)) %>% \n  ungroup()\n```\n:::\n\n\nThe PANAS could be solved more concisely with the skills we learn in @sec-wrangling2, but for now, you would have solved it this way:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# PANAS - positive affect pre\nPANAS_PA_pre <- dog_data_raw %>% \n  # Step 1\n  select(RID, PN1_3, PN1_5, PN1_7, PN1_8, PN1_10) %>% \n  # Step 2\n  pivot_longer(cols = -RID, names_to = \"Items\", values_to = \"Scores\") %>% \n  # Step 3\n  group_by(RID) %>% \n  summarise(PANAS_PA_pre = mean(Scores)) %>% \n  ungroup()\n\n# PANAS - positive affect post\nPANAS_PA_post <- dog_data_raw %>% \n  # Step 1\n  select(RID, PN2_3, PN2_5, PN2_7, PN2_8, PN2_10) %>% \n  # Step 2\n  pivot_longer(cols = -RID, names_to = \"Items\", values_to = \"Scores\") %>% \n  # Step 3\n  group_by(RID) %>% \n  summarise(PANAS_PA_post = mean(Scores)) %>% \n  ungroup()\n\n# PANAS - negative affect pre\nPANAS_NA_pre <- dog_data_raw %>% \n  # Step 1\n  select(RID, PN1_1, PN1_2, PN1_4, PN1_6, PN1_9) %>% \n  # Step 2\n  pivot_longer(cols = -RID, names_to = \"Items\", values_to = \"Scores\") %>% \n  # Step 3\n  group_by(RID) %>% \n  summarise(PANAS_NA_pre = mean(Scores)) %>% \n  ungroup()\n\n# PANAS - negative affect post\nPANAS_NA_post <- dog_data_raw %>% \n  # Step 1\n  select(RID, PN2_1, PN2_2, PN2_4, PN2_6, PN2_9) %>% \n  # Step 2\n  pivot_longer(cols = -RID, names_to = \"Items\", values_to = \"Scores\") %>% \n  # Step 3\n  group_by(RID) %>% \n  summarise(PANAS_NA_post = mean(Scores)) %>% \n  ungroup()\n```\n:::\n\n\nHappiness scale\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# happiness_pre\nhappiness_pre <- dog_data_raw %>% \n  # Step 1\n  select(RID, HA1_1, HA1_2, HA1_3) %>% \n  # Step 2\n  pivot_longer(cols = -RID, names_to = \"Item\", values_to = \"Score\") %>% \n  # Step 3\n  group_by(RID) %>% \n  summarise(SHS_pre = mean(Score)) %>% \n  ungroup()\n\n#happiness_post\nhappiness_post <- dog_data_raw %>% \n  # Step 1\n  select(RID, HA2_1, HA2_2, HA2_3) %>% \n  # Step 2\n  pivot_longer(cols = -RID, names_to = \"Item\", values_to = \"Score\") %>% \n  # Step 3\n  group_by(RID) %>% \n  summarise(SHS_post = mean(Score)) %>% \n  ungroup()\n```\n:::\n\n\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}