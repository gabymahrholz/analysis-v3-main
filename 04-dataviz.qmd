# Data viz I {#sec-dataviz}

```{r include=FALSE}
library(tidyverse)
library(palmerpenguins)
library(patchwork)

# Layers
# https://intro2r.com/the-start-of-the-end.html
```

## Intended Learning Outcomes {.unnumbered}

By the end of this chapter you should be able to:

-   explain the layered grammar of graphics
-   choose an appropriate plot for categorical variables
-   create a basic version of an appropriate plot
-   apply extra layers to change the appearance of the plot

## [Individual Walkthrough]{style="color: #F39C12; text-transform: uppercase;"} {.unnumbered}

## Building plots

We are using the package `ggplot2` to create data visualisations. It's part of the tidyverse package. Actually, most people call th package `ggplot` but it's official name is `ggplot2`.

::: grid
::: g-col-5
**ggplot2** uses a layered grammar of graphics, in which plots are built up in a series of layers. You would start with a base layer (opening ggplot), adding **data** and **aesthetics**, and selecting the **geometries** for plot.

These first 3 layers will give you the most simple version of a complete plot, but you could add other layers to make the plots pretty by using **scales**, **facets**, **coordinates**, **labels** and **themes**.
:::

::: g-col-7
![gg layers [(Presentation by Ryan Safner)](https://metricsf20.classes.ryansafner.com/slides/1.3-slides#20){target="_blank"}](images/gglayers.png){width="70%"}
:::
:::

To give you a brief overview of the layering system, let's use the package `palmerpenguins` ([https://allisonhorst.github.io/palmerpenguins/](https://allisonhorst.github.io/palmerpenguins/){target="_blank"}). It contains data about bill length and depth, flipper length, and body mass, etc.

```{r}
head(penguins)
```

Let's build a basic scatterplot to show the relationship between `flipper_length` and `body_mass`. We will customise plots further later on in the individual plots. This is just a quick overview of the different layers.

-   Layer 1 creates a plot base to built up upon.
-   Layer 2 adds the `data` and some `aesthetics`
    -   data is first argument
    -   aesthetics are added via the mapping argument. There you define your variables to be added (such as x, or x and y) and allows you specify overall properties like the colour of grouping variables etc.
-   Layer 3 adds the geometries or `geom_?` for short. This tells ggplot in which style we want to plot the data points. Remember to add these layers with a `+` rather than a pipe `%>%`. You can add multiple geoms if you wish, e.g., building a violin-boxplot
-   Layer 4 adds the `scale_?` functions which can help you customise the aesthetics, such as changing colour. You can do much more with scales, but we'll get to that later.
-   Layer 5 introduces `facets`, such as `facet_wrap()` which allows you to add another dimension to the data output by showing the relationship you are interested in for each level of a categorical variable.
-   Layer 6 - coordinates: `coord_cartesian()` controls the limits for the x- and y-axes (arguments `xlim` and `ylim`). Changing those allows you to zoom in or out of your plot.
-   Layer 7 helps you to modify axes labels.
-   Layer 8 controls the general style of a ggplot (e.g., background colour, size of text, borders, etc.). R comes with a few pre-defined ones (like `theme_classic`, `theme_bw`, `theme_minimal`, `theme_light`).

Click on the tabs below to see how each layer contributes to refining the plot.

::: {.panel-tabset}
## Layer 1

```{r}
ggplot()
```

We don't see much here. It's basically an empty plot layer.

## Layer 2

```{r}
ggplot(data = penguins, mapping = aes(x=body_mass_g, y=flipper_length_mm))
```

You won't see any data points yet, because we haven't specified how we want to display the data points. But we mapped in the aesthetics, that we want to plot variable body mass on the x-axis and flipper length on the y-axis. This also adds the axes titles and the values and break points of the axes.

::: callout-tip
You won't need to add `data =` or `mapping =` if you keep those arguments in exactly that order. Likewise, the first column name you enter within the `aes()` function will always be interpreted as x, and the second as y, so you could omit them if you wish.

```{r eval = FALSE}
ggplot(penguins, aes(body_mass_g, flipper_length_mm))
```

will give you the same output as the code above.
:::

## Layer 3

```{r}
ggplot(data = penguins, mapping = aes(x=body_mass_g, y=flipper_length_mm, colour=sex)) +
  geom_point()
```

Here we are telling ggplot that we want a scatterplot added. There is a warning displayed showing that rows were removed because of missing values.

The argument `colour` adds colour to the points according to a grouping variable (in this case sex). If you want all of the points to be black (i.e. only represent 2 rather than 3 dimensions of the data), leave the `colour` argument out.

## Layer 4

```{r}
ggplot(data = penguins, mapping = aes(x=body_mass_g, y=flipper_length_mm, colour=sex)) +
  geom_point() +
  # changes colour palette
  scale_colour_brewer(palette = "Dark2") + 
  # add breaks from 2500 to 6500 in increasing steps of 500
  scale_x_continuous(breaks = seq(from = 2500, to = 6500, by = 500)) 
  
```

The `scale_?` functions allow us to change the colour palette of the plot or the axes breaks etc. You could change the name of the axis in `scale_x_continuous()` as well or leave it for Layer 7.

## Layer 5

```{r}
ggplot(data = penguins, mapping = aes(x=body_mass_g, y=flipper_length_mm, colour=sex)) +
  geom_point() +
  scale_colour_brewer(palette = "Dark2") + 
  # split main plot up into different subplots by species 
  facet_wrap(~ species) 

```

Here we are faceting this plot out for the individual species.

## Layer 6

```{r}
ggplot(data = penguins, mapping = aes(x=body_mass_g, y=flipper_length_mm, colour=sex)) +
  geom_point() +
  scale_colour_brewer(palette = "Dark2") + 
  facet_wrap(~ species) +
  # limits the range of the y axis
  coord_cartesian(ylim = c(0, 250)) 
```

Changing the limits of the y axis to zoom in or out of the plot. If you wanted to the same for the x axis, you would add an argument `xlim` to the `coord_cartesian()` function.

## Layer 7

```{r}
ggplot(data = penguins, mapping = aes(x=body_mass_g, y=flipper_length_mm, colour=sex)) +
  geom_point() +
  scale_colour_brewer(palette = "Dark2") + 
  facet_wrap(~ species) +
  labs(x = "Body Mass (in g)", # labels the x axis
       y = "Flipper length (in mm)", # labels the y axis
       colour = "Sex") # labels the grouping variable in the legend
```

You can change the axes labels via the `labs()` function or include that step when modifying the scales (i.e. in the `scale_x_continuous()` function).

## Layer 8

```{r}
ggplot(data = penguins, mapping = aes(x=body_mass_g, y=flipper_length_mm, colour=sex)) +
  geom_point() +
  scale_colour_brewer(palette = "Dark2") + 
  facet_wrap(~ species) +
  labs(x = "Body Mass (in g)", 
       y = "Flipper length (in mm)",
       colour = "Sex") +
  # add a theme
  theme_classic()

```

`theme_classic()` is applied to change the overall appearance of the plot.
:::

::: callout-important
You need to stick to the first 3 layers to get your base plot. Everything else is optional meaning you don't have to use all 8 layers in a plot. And layers 4-8 can be added in a random order whereas layers 1-3 are fixed.
:::

## Activity 1: Set-up and data for today

-   We are still working with the data by Pownall et al. (2023) which we aggregated in @sec-wrangling. So, open your project.
- However, we could do with a fresh Rmd: Create a new Rmd and save it to your project folder. Name it something meaningful (e.g., "chapter_04", "04_data_viz.Rmd"). See @sec-rmd if you need some guidance. Delete everything below line 12 (keep the set-up code chunk)
-   We aggregated the data in @sec-wrangling. If you want a fresh copy, download the data here: [data_prp_for_ch4.csv](data/data_prp_for_ch4.csv "download"). Make sure to place the csv file in the project folder.
-   If you need a reminder about the data and variables, have a look at the codebook and/or @sec-download_data_ch1.



## Activity 2: Load in the libraries and read in the data

We need the package `tidyverse` today, and the data `data_prp_for_ch4.csv`.

```{r eval=FALSE}
## packages 
???

## data
data_prp_viz <- read_csv(???)
```

::: {.callout-note collapse="true" icon="false"}

## Solution

```{r eval=FALSE}
library(tidyverse)
data_prp_viz <- read_csv("data_prp_for_ch4.csv")
```

:::


```{r include=FALSE}
## I basically have to have 2 code chunks since I tell them to put the data files next to the project, and mine are in a separate folder called data - unless I'll turn this into a fixed path

library(tidyverse)
data_prp_viz <- read_csv("data/data_prp_for_ch4.csv")
```

#### Re-familiarise yourself with the data structure {.unnumbered}

As we said in @sec-familiarise, it is always recommended to glimpse at the data to see how many variables and observations there are in the dataset and what kind of data type they are.

::: {.callout-note collapse="true"}
## glimpse output

```{r}
glimpse(data_prp_viz)
```

:::


We can see that some of the categorical data in `data_prp_viz` was read in as numeric variables which makes them continuous. This is going to haunt us big time when building the plots. We would be better off addressing these changes in the dataset before we start plotting (and potentially getting frustrated with R and data viz in general)

Let’s turn a few of the categorical variables into factors.

```{r}
data_prp_viz <- data_prp_viz %>% 
  mutate(Gender = factor(Gender,
                         levels = c(2, 1, 3),
                         labels = c("females", "males", "non-binary")),
         Secondyeargrade = factor(Secondyeargrade,
                                  levels = c(1, 2, 3, 4, 5),
                                  labels = c("≥ 70% (1st class grade)", "60-69% (2:1 grade)", "50-59% (2:2 grade)", "40-49% (3rd class)", "< 40%")),
         Plan_prereg = factor(Plan_prereg,
                              levels = c(1, 3, 2),
                              labels = c("Yes", "Unsure", "No")),
         Closely_follow = factor(Closely_follow,
                                 levels = c(2, 3),
                                 labels = c("Followed it somewhat", "Followed it exactly")),
         Research_exp = factor(Research_exp),
         Pre_reg_group = factor(Pre_reg_group))

```



## Appropriate plots? {.unnumbered}

Now we can think about which plot is the appropriate plot for your data. Different types of variables require different types of plots, so this comes back to how many variables are you aiming to plot and what kind of data type are they. The following part is organised by type of variable.


Today, we will focus on plots for categorical data. Next week, we'll cover plots for continuous variables and discover which plots are appropriate if you have a mix of continuous and categorical variables


## One categorical variable

### Barchart (`geom_bar()`)

Let's say we want to count some demographics. To keep it simple, we want to show gender counts. We would use a **barplot** for it. This is done with `geom_bar()` in your third layer, and because the counting is done in the background, the `aes` only requires an x value (i.e. the name of your variable).

```{r fig-bc-base, fig.cap="Default barchart"}
ggplot(data_prp_viz, aes(x = Gender)) +
  geom_bar() 
```

This is the base plot done. You can customise it by adding different layers. For example, the labels aren't super clear or it could do with a dash of colour. Click on the tabs below to see examples of what could be added and practice on your base plot in your own Rmd.



::: {.panel-tabset}
## Colour

We can change the colour by adding a fill argument in the `aes()`. If we want to modify these colours further, we would add a `scale_fill_?` argument. If you have specific colours in mind, you would use `scale_fill_manual()` or if you want to stick with pre-defined ones, like viridis, use `scale_fill_viridis_d()`

```{r}
ggplot(data_prp_viz, aes(x = Gender, fill = Gender)) +
  geom_bar() +
  # customise colour
  scale_fill_viridis_d()
```

## Axes labels & margins

The x-axis label is fine, but the categories need to be relabeled. You can achieve that with the `scale_x_discrete()` function and the argument `labels =`. But make sure you order them in the order of the labels in the dataframe.

There is also this gap between bottom of the chart and the bars which seems a bit weird. We can remove that with an `expansion()` function.

```{r}
ggplot(data_prp_viz, aes(x = Gender, fill = Gender)) +
  geom_bar() +
  scale_fill_viridis_d() +
  # changing group labels on the breaks of the x axis
  scale_x_discrete(labels = c("Female", "Male", "Non-Binary")) + 
  scale_y_continuous(
    # changing name of the y axis
    name = "Count",
    # remove the space below the bars (first number), but keep a tiny bit (5%) above (second number)
    expand = expansion(mult = c(0, 0.05))
  )
  
```

## Legend

The legend does not add any information because the labels are already provided on the x axis. We can remove the legend by adding the argument `guide = "none"` into the `scale_fill` function.

```{r}
ggplot(data_prp_viz, aes(x = Gender, fill = Gender)) +
  geom_bar() +
  scale_fill_viridis_d(
    # remove the legend
    guide = "none") +
  scale_x_discrete(labels = c("Female", "Male", "Non-Binary")) +
  scale_y_continuous(
    name = "Count",
    expand = expansion(mult = c(0, 0.05))
  )
  
```

## Themes

Let's experiment with the themes. For this plot we have chosen `theme_minimal()`

```{r}
ggplot(data_prp_viz, aes(x = Gender, fill = Gender)) +
  geom_bar() +
  scale_fill_viridis_d(
    guide = "none") +
  scale_x_discrete(labels = c("Female", "Male", "Non-Binary")) +
  scale_y_continuous(
    name = "Count",
    expand = expansion(mult = c(0, 0.05))
  ) +
  # pick a theme
  theme_minimal()
  
```
:::

### Column plot (`geom_col()`)

If someone had already summarised those counts for you, you would not be able to use `geom_bar()`. In that case, you would switch to `geom_col()`.

```{r}
gender_count <- data_prp_viz %>% 
  count(Gender)

gender_count
```

The mapping for `geom_col()` requires both an **x** and a **y** aesthetics. In our example, x would be our categorical variable (e.g., `Gender`), and y would be the column name that stored the values (`n`). Note how the base version has now n as an axis title (instead of count).

```{r fig-col, fig.cap="Column plot with different coloured bars"}
ggplot(gender_count, aes(x = Gender, y = n, fill = Gender)) +
  geom_col()
```

### Activity 3: Make the column plot pretty

The other layers to change the colour scheme, axes labels and margins, removing the legend and altering the theme require exactly the same functions as with the boxplot above. Test yourself to see if you could...

-   [ ] change the colour scheme (e.g., viridis or [any other colour palettes](https://www.datanovia.com/en/blog/the-a-z-of-rcolorbrewer-palette/){target="_blank"})
-   [ ] remove the legend
-   [ ] change the title of the x and y axes
-   [ ] make the bars start directly on the x axis
-   [ ] add a theme of your linking

::: {.callout-tip collapse="true"}
## Possible solution code for the column plot (with a different colour palette and a different theme)

```{r}
ggplot(gender_count, aes(x = Gender, y = n, fill = Gender)) +
  geom_col() +
  # replaced vidiris with the brewer palette
  scale_fill_brewer(
    palette = "Set1", # try "Set2" or "Dark2" for some variety
    guide = "none") + # legend removed
  # labels of the categories changed
  scale_x_discrete(labels = c("Male", "Female", "Non-Binary")) + 
  scale_y_continuous(
    # change y axis label
    name = "Count",
    # starts bars on x axis without any gaps but leaves some space at the top (this time 10%)
    expand = expansion(mult = c(0, 0.1)) 
  ) +
  # different theme
  theme_light()
```
:::

## Two categorical variables

For this task, we can look at the variable `Plan_prereg` measuring whether they planned to pre-register their undergraduate dissertation at time point 1, and `Pre_reg_group` whether they actually ended up doing a pre-registration for their undergraduate dissertations.

### Stacked and percent stacked barchart

One way to display that data is by creating a **Stacked barchart** (default option) or a **Percent stacked barchart**. For both options, the subgroups are displayed on top of each other. To show the two plots next to each other for better comparison, we moved the legend to the bottom of the chart.

```{r, eval=FALSE}
## Stacked barchart
ggplot(data_prp_viz, aes(x = Plan_prereg, fill = Pre_reg_group)) +
  geom_bar() + # no position argument added
  theme(legend.position = "bottom") # move legend to the bottom

## Percent stacked barchart
ggplot(data_prp_viz, aes(x = Plan_prereg, fill = Pre_reg_group)) +
  geom_bar(position = "fill") + # add position argument here
  theme(legend.position = "bottom") # move legend to the bottom
```

```{r, fig-barcharts_stacked, fig.cap="Stacked barchart (left), and Percent stacked barchart (right)", echo=FALSE}
## Stacked barchart
bc_stacked <- ggplot(data_prp_viz, aes(x = Plan_prereg, fill = Pre_reg_group)) +
  geom_bar() + # add position argument here
  theme(legend.position = "bottom") + # move legend to the bottom
  guides(fill = guide_legend(nrow = 1)) # display across 2 rows

## Percent stacked barchart
bc_percent <- ggplot(data_prp_viz, aes(x = Plan_prereg, fill = Pre_reg_group)) +
  geom_bar(position = "fill") + # add position argument here
  theme(legend.position = "bottom") + # move legend to the bottom
  guides(fill = guide_legend(nrow = 1)) # display across 2 rows

bc_stacked + bc_percent + plot_layout(nrow = 1)
```

In the **stacked barchart** (@fig-barcharts_stacked, left plot), you are able to plot participant numbers. Here we can see that the highest student number were unsure whether they wanted to pre-register their dissertation or not, followed closely by participants who answered yes. We can also see that the number of people who did not end up with a pre-registered dissertation (blue category) is the same for students who had planned to pre-register and those who did not want to pre-register. However, because `No` has quite a lower number than the other two categories, we are having a tough time seeing whether the ratio is the same across all 3 groups.

If we wanted to show that, a **Percent stacked barchart** (@fig-barcharts_stacked, right plot) would make a lot more sense. Now we would see that approximately 80% of the students who wanted to pre-register their dissertations, 50% of the students who were initially unsure, and only 33% of the students who had no pre-registration plans ended up with a ended up with a pre-registered dissertation. BUT! We would lose the information about the raw values in the sample.

**It's all a trade-off and the plot you choose depends on which "story" of the data you want to tell.**

::: callout-note
The position argument `position = "stack"` is the default. Adding this argument to the code for the left plot in @fig-barcharts_stacked would produce the same plot a leaving the argument out.
:::

### Grouped barchart

A second option is a **Grouped barchart** which displays the bars next to each other. We would achieve that by changing the position argument to **"dogde"**. You can see the default version of the plot in the @fig-barchart_grouped on the left, and one with more layers on the right.

Instead of using an existing colour palette, we changed the colours manually using hex codes. These are some of the colours Gaby used in her PhD, but you can either 

* create your own colour hex codes; check out [this website](https://www.hexcolortool.com/){target="_blank"} OR
* use a pre-defined colour name like "green" or "purple instead. See a full list [here](https://www.datanovia.com/en/blog/awesome-list-of-657-r-color-names/){target="_blank"}

Feel free to explore.

Since the legend title for the second plot is a bit long, we displayed the legend content across 2 rows by adding the layer `guides(fill = guide_legend(nrow = 2))` at the end.



```{r eval=FALSE}
## Default grouped barchart
ggplot(data_prp_viz, aes(x = Plan_prereg, fill = Pre_reg_group)) +
  geom_bar(position = "dodge") + # add position argument here
  theme(legend.position = "bottom") # move legend to the bottom

## Prettier grouped barchart
ggplot(data_prp_viz, aes(x = Plan_prereg, fill = Pre_reg_group)) +
  geom_bar(position = "dodge") + # add position argument here
  # changing labels for x, y, and fill category - alternative method
  labs(x = "Pre-registration planned", y = "Count", fill = "Pre-registered dissertation") +
  # manual colour change for values
  scale_fill_manual(values = c('#648FFF', '#DC267F'),
                    labels = c("Yes", "No")) +
  scale_y_continuous(
    # remove the space below the bars, but keep a tiny bit (5%) above
    expand = expansion(mult = c(0, 0.05))
  ) +
  # pick a theme
  theme_classic() + 
  theme(legend.position = "bottom") + # need to move this part to the end otherwise the `theme_*` overrides it
  guides(fill = guide_legend(nrow = 2)) # display legend categories across 2 rows
  
```

```{r fig-barchart_grouped, fig.cap="Default grouped barchart (left) and one with a few more layers added (right)", echo=FALSE}
gbc_default <- ggplot(data_prp_viz, aes(x = Plan_prereg, fill = Pre_reg_group)) +
  geom_bar(position = "dodge") + # add position argument here
  theme(legend.position = "bottom") # move legend to the bottom

## Prettier grouped barchart
gbc_pretty <- ggplot(data_prp_viz, aes(x = Plan_prereg, fill = Pre_reg_group)) +
  geom_bar(position = "dodge") + # add position argument here
  # changing labels for x, y, and fill category - alternative method
  labs(x = "Pre-registration planned", y = "Count", fill = "Pre-registered dissertation") +
  # manual colour change for values
  scale_fill_manual(values = c('#648FFF', '#DC267F'),
                    labels = c("Yes", "No")) +
  scale_y_continuous(
    # remove the space below the bars, but keep a tiny bit (5%) above
    expand = expansion(mult = c(0, 0.05))
  ) +
  # pick a theme
  theme_classic() + 
  theme(legend.position = "bottom") + # need to move this part to the end otherwise the `theme_*` overrides it
  guides(fill = guide_legend(nrow = 2)) # display across 2 rows

gbc_default + gbc_pretty + plot_layout(nrow = 1)  
```


::: {.callout-tip collapse="true" icon="false"}

## Special case: Categorical variables with missing values

If we had chosen a different categorical variable containing missing values, such as `Closely_follow` then our plots would have included those missing values by default. The code for changing the colour of the missing values columns would need to be specified slightly differently using an `na.value =` argument within the `scale_fill` function. Here is an example of a grouped barchart.


```{r eval=FALSE}
# default grouped barchart with missing values
ggplot(data_prp_viz, aes(x = Plan_prereg, fill = Closely_follow)) +
  geom_bar(position = "dodge") + 
  theme(legend.position = "bottom") + 
  guides(fill = guide_legend(nrow = 3)) # display across 3 rows

## Prettier grouped barchart with missing values
ggplot(data_prp_viz, aes(x = Plan_prereg, fill = Closely_follow)) +
  geom_bar(position = "dodge") + 
  labs(x = "Pre-registration planned", y = "Count", fill = "Pre-registration followed") +
  # manual colour change for values of the factor and the NA responses
  scale_fill_manual(values = c('#648FFF', '#DC267F'), na.value = '#FFB000') +
  scale_y_continuous(
    expand = expansion(mult = c(0, 0.05))
  ) +
  theme_classic() + 
  theme(legend.position = "bottom") + 
  guides(fill = guide_legend(nrow = 3)) # display across 3 rows
```

```{r fig-barchart_grouped_na, fig.cap="Default grouped barchart (left) and one with a few more layers added (right) for a variable with missing values", echo=FALSE}
gbc_default <- ggplot(data_prp_viz, aes(x = Plan_prereg, fill = Closely_follow)) +
  geom_bar(position = "dodge") + 
  theme(legend.position = "bottom") + 
  guides(fill = guide_legend(nrow = 3)) # display across 3 rows

## Prettier grouped barchart with missing values
gbc_pretty <- ggplot(data_prp_viz, aes(x = Plan_prereg, fill = Closely_follow)) +
  geom_bar(position = "dodge") + 
  labs(x = "Pre-registration planned", y = "Count", fill = "Pre-registration followed") +
  # manual colour change for values of the factor and the NA responses
  scale_fill_manual(values = c('#648FFF', '#DC267F'), na.value = '#FFB000') +
  scale_y_continuous(
    expand = expansion(mult = c(0, 0.05))
  ) +
  theme_classic() + 
  theme(legend.position = "bottom") + 
  guides(fill = guide_legend(nrow = 3)) # display across 3 rows

gbc_default + gbc_pretty + plot_layout(nrow = 1)  
```

If you did not want those missing values to appear in the plot, you would have to do some data wrangling first to remove them. The function for that is `drop_na()`. Here we used `drop_na()` on `Closely_follow` only.


```{r}
# remove NA
prereg_plan_follow <- data_prp_viz %>% 
  select(Code, Plan_prereg, Closely_follow) %>% 
  drop_na(Closely_follow)
```


::: {.callout-note collapse="true" icon="false"}

## check NAs have been removed

```{r}
# check NA have been removed
prereg_plan_follow %>% 
  distinct(Plan_prereg, Closely_follow) %>% 
  arrange(Plan_prereg, Closely_follow)
```

:::

But keep in mind that it could misrepresent the data, e.g., giving a wrong impression about proportions. As a comparison...

```{r eval=FALSE}
# with NA
ggplot(data_prp_viz, aes(x = Plan_prereg, fill = Closely_follow)) +
  geom_bar(position = "fill") + # add position argument here
  theme(legend.position = "bottom") + # move legend to the bottom
  guides(fill = guide_legend(nrow = 2)) # display across 2 rows

# without NA
ggplot(prereg_plan_follow, aes(x = Plan_prereg, fill = Closely_follow)) +
  geom_bar(position = "fill") + # add position argument here
  theme(legend.position = "bottom") + # move legend to the bottom
  guides(fill = guide_legend(nrow = 2)) # display across 2 rows
```

```{r fig-barchart_na_no_na, echo=FALSE, fig.cap="Percent stacked barchart with (left) and without missing values (right)"}
# with NA
comp_a <- ggplot(data_prp_viz, aes(x = Plan_prereg, fill = Closely_follow)) +
  geom_bar(position = "fill") + # add position argument here
  theme(legend.position = "bottom") + # move legend to the bottom
  guides(fill = guide_legend(nrow = 2)) # display across 2 rows

# without NA
comp_b <- ggplot(prereg_plan_follow, aes(x = Plan_prereg, fill = Closely_follow)) +
  geom_bar(position = "fill") + # add position argument here
  theme(legend.position = "bottom") + # move legend to the bottom
  guides(fill = guide_legend(nrow = 2)) # display across 2 rows

comp_a + comp_b + plot_layout(nrow = 1)
```

:::


## Activity 4: Save your plots

You can save your figures with the function `ggsave()`. It will save to your project folder.

There are two ways you can use `ggsave()`. If you don't tell `ggsave()` which plot you want to save, by **default** it will **save the last plot you created**. Our last plot was the one without `NA` from the special case scenario  (@fig-barchart_na_no_na). However, if you did not follow along with the special case scenario, your last plot will be grouped bar chart on the right from @fig-barchart_grouped.

```{r eval=FALSE}
ggsave(filename = "last_plot.png")
```

```{r include=FALSE}
ggplot(prereg_plan_follow, aes(x = Plan_prereg, fill = Closely_follow)) +
  geom_bar(position = "fill") + # add position argument here
  theme(legend.position = "bottom") + # move legend to the bottom
  guides(fill = guide_legend(nrow = 2)) # display across 2 rows

ggsave(filename = "images/last_plot.png")
```

::: {.callout-note collapse="true"}

## Our last plot saved

![](images/last_plot.png)
:::


The second option is to save the plot as an object and refer to the object within `ggsave()`. As an example, let's save the grouped barchart that contained missing values (@fig-barchart_grouped) as an object called `grouped_bar`.

```{r}
grouped_bar <- ggplot(data_prp_viz, aes(x = Plan_prereg, fill = Closely_follow)) +
  geom_bar(position = "dodge") + 
  labs(x = "Pre-registration planned", y = "Count", fill = "Pre-registration followed") +
  # manual colour change for values of the factor and the NA responses
  scale_fill_manual(values = c('#648FFF', '#DC267F'), na.value = '#FFB000') +
  scale_y_continuous(
    expand = expansion(mult = c(0, 0.05))
  ) +
  theme_classic() + 
  theme(legend.position = "bottom") + 
  guides(fill = guide_legend(nrow = 3)) # display across 3 rows
```

Then you run the line

```{r eval=FALSE}
ggsave(filename = "grouped_bar.png", 
       plot = grouped_bar)
```

```{r echo=FALSE}
ggsave(filename = "images/grouped_bar.png", 
       plot = grouped_bar)
```

Filename is the name you want your png to be called, plot refers to the object name. 


::: {.callout-note collapse="true"}

## Our saved `grouped_bar.png` would look like this:

![](images/grouped_bar.png)
:::

That is with default settings. If you like it, keep it, but if you think it looks a bit "stretched", you can specify the width, the height, and the units (e.g., "cm", "mm", "in", "px" are possible). You might need to play about with the dimension before it feels right.

```{r eval=FALSE}
ggsave(filename = "grouped_bar2.png", 
       plot = grouped_bar, 
       width = 16, height = 9, units = "cm")
```

```{r echo=FALSE}
ggsave(filename = "images/grouped_bar2.png", 
       plot = grouped_bar, 
       width = 16, height = 9, units = "cm")
```

::: {.callout-note collapse="true"}

## png with different dimensions

![](images/grouped_bar2.png)
:::



## Activity 5: Your Turn

Pick **any single or two categorical variables** from the dataset and **choose one of the appropriate plot choices**. Start with a base plot and add other layers if you please. 

Save your plot and share it with us on Teams.



## [Pair-coding]{style="color: #F39C12; text-transform: uppercase;"} {.unnumbered}

Provide a barchart, a violin-boxplot, and a scatterplot from the loneliness data and the students have to try and recreate one of those in the lab. If they are overly fast, they can do the other 2.

## [Test your knowledge]{style="color: #F39C12; text-transform: uppercase;"} {.unnumbered}

Which plot would you choose for






