# Projects, R Markdown, and Data Wrangling

## Intended Learning Outcomes {.unnumbered}

By the end of this chapter you should be able to:

-   Re-familiarise yourself with setting up projects
-   Re-familiarise yourself with RMarkdown documents
-   Recap and apply data wrangling procedures to analyse data

## [Individual Walkthrough]{style="color: #EBA347; text-transform: uppercase;"} {.unnumbered}

## R and R Studio

Remember, R is a programming language that you will write code in and RStudio is an Integrated Development Environment (IDE) which makes working with R easier as it's more user friendly. You need both components for this course.

If this is not ringing any bells yet, have a quick browse through the [materials from year 1](https://psyteachr.github.io/data-skills-v2/sec-intro.html?q=RMark#sec-intro-r){target="_blank"} to refresh your memory.

### R server

R and RStudio are already installed on the *R server*. We recommend using the server if your computer does not allow installation (e.g., a Chromebook), or if you have problems installing R on your computer. Otherwise, you should consider installing R and RStudio on your own computer.

You will find the link to the server on Moodle.

### Installing R and RStudio on your computer

@sec-installing-r has detailed instructions on how to install R and RStudio on your own computer. There are also some links to a series of walkthroughs for installing R on different types of computers/ operating systems.

If you had R and RStudio installed on your own computer last year, we recommend updating to the latest versions. In fact, it might be good to do that at the start of each academic year. Detailed guidance can be found in @sec-updating-r.

Once you have installed/updated R and RStudio, come back to this chapter.

### Settings for Reproducibility

By now you should be aware that the Psychology department at the University of Glasgow is pretty big on reproducibility, open science, and raising students' awareness about questionable research practices (QRPs) and how to avoid them. Therefore, you should be doing things reproducibly so that others (and your future self) can understand and check your work. That also allows you to reuse your work more easily.

Always start with a clear workspace. Keeping anything in your `Global Environment` from a previous session means you can never be sure whether your current code is working or if your code is accessing previously created objects.

Hence, there are a few settings you should fix immediately after installing/updating RStudio, in <if>Tools \> Global Options... General tab</if>

-   uncheck the box that says <if>Restore .RData into workspace at startup</if> to make sure no data from a previous session is loaded into the environment
-   set <if>Save workspace to .RData on exit</if> to **Never** so that your workspace is not saved when you exit RStudio.

![Reproducibility settings in Global Ootions](images/rstudio_settings_reproducibility.png)



### RStudio panes

RStudio has four main panes each in a quadrant of your screen:

-   Source pane
-   Environment pane
-   Console pane
-   Output pane

Let's see what you remember about the RStudio panes from last year. Click on the **Test your understanding** section below and give it a go.

::: {.callout-note collapse="true"}
## Test your understanding

**What is their purpose?**

**The Source pane...** `r longmcq(c(answer = "allows users to view and edit various code-related files, such as .Rmd files", "contains the Files, Plots, R Packages, Help, Tutorial, Viewer, and Presentation tabs", "includes the Environment tab that displays currently saved objects, and the History tab that displays the commands that were executed in the current session along a search function", "provides an area to interactively execute code"))`

**The Environment pane...** `r longmcq(c("allows users to view and edit various code-related files, such as .Rmd files", "contains the Files, Plots, R Packages, Help, Tutorial, Viewer, and Presentation tabs", answer = "includes the Environment tab that displays currently saved objects, and the History tab that displays the commands that were executed in the current session along a search function", "provides an area to interactively execute code"))`

**The Console pane...** `r longmcq(c("allows users to view and edit various code-related files, such as .Rmd files", "contains the Files, Plots, R Packages, Help, Tutorial, Viewer, and Presentation tabs", "includes the Environment tab that displays currently saved objects, and the History tab that displays the commands that were executed in the current session along a search function", answer = "provides an area to interactively execute code"))`

**The Output pane...** `r longmcq(c("allows users to view and edit various code-related files, such as .Rmd files", answer = "contains the Files, Plots, R Packages, Help, Tutorial, Viewer, and Presentation tabs", "includes the Environment tab that displays currently saved objects, and the History tab that displays the commands that were executed in the current session along a search function", "provides an area to interactively execute code"))`

**Where are these panes located by default?**

-   The Source pane is located? `r mcq(sample(c(answer = "top left", "bottom left", "top right", "bottom right")))`
-   The Environment pane is located? `r mcq(sample(c("top left", "bottom left", answer = "top right", "bottom right")))`
-   The Console pane is located? `r mcq(sample(c("top left", answer = "bottom left", "top right", "bottom right")))`
-   The Output pane is located? `r mcq(sample(c("top left", "bottom left", "top right", answer = "bottom right")))`
:::

If you were not quite sure about one/any of the panes, check out the [materials from Level 1](https://psyteachr.github.io/data-skills-v2/sec-intro.html?q=RMark#rstudio-panes){target="_blank"}. If you want to know more about them, there is the [RStudio guide on posit](https://docs.posit.co/ide/user/ide/guide/ui/ui-panes.html){target="_blank"}

## Activity 1: Creating a new project {#sec-project}

It's important that we create a new RStudio project every time we start a new project. It makes life easier to work in multiple contexts, for example when analysing different datasets at the same time. Every RStudio project has their folder location, workspace, and working directories, basically keeping all the data and the RMarkdown documents in one location.

Last year, you learnt how to create projects on the server, so you already know the steps. If cannot quite recall how that was done, go back to the [Level 1 materials](https://psyteachr.github.io/data-skills-v2/sec-intro.html?q=RMark#new-project){target="_blank"}.

On your own computer, open RStudio, and complete the following steps in this order:

-   Click on <if>File \> New Project...</if>
-   Then, click on "New Directory"
-   Then, click on "New Project"
-   Name the directory something meaningful (e.g., "2A_chapter1"), and save it in a location that makes sense, for example, a dedicated folder you have for your level 2 Psychology labs - you can either select a folder you have already in place, or create a new one (e.g., I named my new folder "Level 2 labs")
-   Click "Create Project". RStudio will restart itself and open with this new project directory as the working directory. If you accidentally close it, you can open it by double-clicking on the project icon in your folder
-   You can also check in your folder structure that everything was created as intended

![Creating a new project](images/project_setup.gif)

::: {.callout-tip title="Why is the Colour scheme in the gif different?" collapse="true"}
In case anyone is wondering why my colour scheme in the gif above looks different to yours, I've set mine to "Pastel On Dark" in <if>Tools \> Global Options... \> Appearances</if>. And my computer lives in "dark mode".
:::

::: callout-important
## Don't nest projects

Don't ever save a new project **inside** another project directory. This can cause some hard-to-resolve problems.
:::

## Activity 2: Create a new R Markdown file {#sec-rmd}

-   Open a new R Markdown document: click <if>File \> New File \> R Markdown</if> or click on the little page icon with a green plus sign (top left).
-   Give it a meaningful `Title` (e.g., Level 2 chapter 1) - you can also change the title later. Feel free to add your name or GUID in the `Author` field author name. Keep the `Default Output Format` as HTML.
-   Once the Rmd opened, you need to save the file.
-   To save it, click <if>File \> Save As...</if> or click on the little disc icon. Name it something meaningful (e.g., "chapter_01.Rmd", "01_intro.Rmd"). Make sure there are no spaces in the name - R is not very fond of spaces... This file will automatically be saved in your project folder (i.e., your working directory) so you should now see this file appear in your file viewer pane.



![Creating a new Rmd file](images/Rmd_setup.gif)



Remember, an R Markdown document or Rmd has "white space" (i.e., the markdown for formatted text) and "grey parts" (i.e., code chunks) in the default colour scheme (see @fig-rmd), and is a great way to create dynamic documents. The key advantage of R Markdown is that it allows you to write code into a document, along with regular text, and then **knit** it using the package `knitr()` to create your document as either a webpage (HTML), a PDF, or Word document (.docx). We'll only knit to html documents in this course.




![R markdown anatomy (image from [https://intro2r.com/r-markdown-anatomy.html](https://intro2r.com/r-markdown-anatomy.html){target="_blank"})](images/rm_components.png)


### Markdown

The markdown space is for formatted text. You can and should write notes for yourself and others on what your code is doing (earlier on) or what decisions you are making. This can be really useful later on, for example, when making decision about inclusion/exclusion criteria or whatever you conclude from your assumption tests.

There is a variety of **heading levels** to make use of, using the # symbol. 

::: {.columns}

::: {.column}

#### You would incorporate this into your text as: {.unnumbered}

\# Heading level 1

\## Heading level 2

\### Heading level 3

\#### Heading level 4

\##### Heading level 5

\###### Heading level 6

:::


::: {.column}

#### And it will be displayed in your knitted html file as: {.unnumbered}

![](images/heading_levels.PNG)

:::

:::



::: {.callout-important collapse="true"}
## My heading levels don't render properly when knitting

You need a space between the # and first letter. If the space is missing, the heading will be displayed in the html as ...

#Heading 1

::: 

You can also include **unordered lists** and **ordered lists**.

:::{.panel-tabset}

## unordered lists

You can add **bullet points** using either `*`, `-` or `+` and they will turn into:

* bullet point (created with `*`)
- bullet point (created with `-`)
+ bullet point (created with `+`)


or use bullet points of different levels using 1 tab key press or 2 spaces (for sub-item 1) or 2 tabs/4 spaces (for sub-sub-item 1):

* bullet point item 1
  * sub-item 1
    * sub-sub-item 1
    * sub-sub-item 2
* bullet point item 2


::: {.callout-important collapse="true"}
## My bullet points don't render properly when knitting

You need an empty row before your bullet points start. If I delete the empty row before the bullet points, they will be displayed in the html as ...

Text without the empty row:
* bullet point created with `*`
- bullet point created with `-`
+ bullet point created with `+`

:::



## ordered lists

Start the line with **1.**, **2.**, etc. When you want to include sub-items, either use the `tab` key twice or add **4 spaces**. Same goes for the sub-sub-item: include either 2 tabs (or 4 manual spaces) from the last item or 4 tabs/ 8 spaces from the start of the line. 

1. list item 1
2. list item 2
    i) sub-item 1 (with 4 spaces)
        A.  sub-sub-item 1 (with an additional 4 spaces from the last indent)


:::{.callout-important collapse="true"}

## My list items don't render properly when knitting

If you don't leave enough spaces, the list won't be recognised and your output looks like this:

3. list item 3
  i) this item has only 2 spaces
    A. this is an indent equivalent to 4 spaces

:::

## ordered lists magic

The great thing though is that you don't need to know your alphabet or number sequences. R markdown will fix that for you

If I type into my Rmd...

![](images/list_magic.PNG)

...it will be rendered in the knitted html output as...

4. list item 3
1. list item 1
    a) sub-item labelled "a)"
    i) sub-item labelled "i)"
        C) sub-item labelled "C)"
        Z) sub-item labelled "Z)"
7. list item 7

:::{.callout-important collapse="true"}

## The labels of the sub-items are not what I thought they would be. You said they are fixing themselves...

Yes, they do but you need to label your sub-item lists accordingly. The first label you list in each level is set as the baseline. If they are labelled `1)` instead of `i)` or `A.`, the output will show as follows, but the automatic-item-fixing still works:

7. list item 7
    1) list item "1)" with 4 spaces
        1) list item "1)" with 8 spaces
        6) this is an item labelled "6)" (magically corrected to "2.")

:::

:::




Include **emphasis** to draw attention to key words in your text:

|R markdown syntax  | Displayed in the knitted html file |
|:----------------- |:-----------------------------------|
| \**bold text**    | **bold text**                      |
| \*italic text*    | *italic text*                      |
| \*\*\*bold and italic\*\*\*    | ***bold and italic***      |                      |

Other examples can be found in the [R Markdown Cheat Sheet](https://www.rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf){target="_blank"}


### Code chunks

Everything you write into the **code chunks** will be interpreted as code and computed by R. Code chunks start with ` ``` ` followed by an `{r}` which specifies the coding language, some space for code, and ends with ` ``` `. If you accidentally delete one of those backticks, your code won't run and/or your text parts will be interpreted as part of the code chunks or vice versa. This should be evident from the colour change - more white than expected if it's one of the starting backticks, and too much grey/not enough white when it's the backticks at the end. But no need to fret - just add the missing backticks manually.

You can **insert a new code chunk** either by

* clicking the `Insert a new code chunk` button in the RStudio Toolbar (green icon at the top right corner of the `Source pane`)
* clicking on the menu <if>Code \> Insert Chunk</if>
* using the shortcut `Ctrl + Alt + I` for Windows and `Cmd + Option + I` on MacOSX or
* typing ` ```{r}` and ` ``` ` manually


```{r fig-rmd, echo=FALSE, fig.cap="Default Rmd with highlighting - names in pink and knitr display options in purple"}
knitr::include_graphics("images/default_highlighted.png")
``` 


Within the curly brackets, you can **specify a name** for your code chunk (see pink highlighting in @fig-rmd). The chunk name is not necessarily required, however, it is good practice to give each chunk a unique name to support more advanced knitting approaches.

Within the the curly brackets, you can also place rules and arguments (see purple highlighting in @fig-rmd) to give you control over how your code is interpreted and what exactly is shown in your html output. The most common **knitr display options** are:


| Code                | Does code run | Does code show | Do results show |
|:--------------------|:-------------:|:--------------:|:---------------:|
| eval=FALSE          | NO            | YES            | NO              |
| echo=TRUE (default) | YES           | YES            | YES             |
| echo=FALSE          | YES           | NO             | YES             |
| results="hide"      | YES           | YES            | NO              |
| include=FALSE       | YES           | NO             | NO              |




::: {.callout-important}
The table above will be incredibly important for the data skills homework II.
:::


-   In your newly created Rmd file, delete everything below line 12 (keep the set-up code chunk) and save your Rmd by clicking on the disc symbol.

![Delete everything below line 12](images/delete_12.gif)



## Activity 3: Download the data

The data for chapters 1 and 2. Download it here: [data_ch1.zip](data/data_ch1.zip "download"). There are 2 csv files contained in a zip-folder. One is the data file we are going to use today `prp_data_reduced_ch1.csv` and the other is an excel file `prp_codebook` that explains the variables in the data.

The first step is to **unzip the zip folder** so that the files are placed within the same folder as your project.

* place the zip folder within your 2A_chapter1 folder
* right mouse click --> `Extract All...`
* Check the folder location is the one to extract the files to
* check the extracted files are placed next to the project icon
* files and project should be visible in the Output pane in RStudio


::: {.callout-note collapse="true"}

## For screenshots click here

::: {layout-ncol=1}

![](images/pic1.PNG){fig-align="center"}

![](images/pic23.PNG){fig-align="center"}

![](images/pic45.PNG){fig-align="center"}

Unzipping a zip folder

:::

:::


The paper was a **registered report** published in 2023, and the original data can be found on OSF ([https://osf.io/5qshg/](https://osf.io/5qshg/){target="_blank"}). However, for the purpose of this chapter, we have modified the data slightly (e.g., reducing the number of variables, editing some data types, etc.) to ensure "teachable moments".

**Citation**

> Pownall, M., Pennington, C. R., Norris, E., Juanchich, M., Smailes, D., Russell, S., Gooch, D., Evans, T. R., Persson, S., Mak, M. H. C., Tzavella, L., Monk, R., Gough, T., Benwell, C. S. Y., Elsherif, M., Farran, E., Gallagher-Mitchell, T., Kendrick, L. T., Bahnmueller, J., . . . Clark, K. (2023). Evaluating the Pedagogical Effectiveness of Study Preregistration in the Undergraduate Dissertation. *Advances in Methods and Practices in Psychological Science, 6*(4). [https://doi.org/10.1177/25152459231202724](https://doi.org/10.1177/25152459231202724){target="_blank"}

**Abstract**

> Research shows that questionable research practices (QRPs) are present in undergraduate final-year dissertation projects. One entry-level Open Science practice proposed to mitigate QRPs is “study preregistration,” through which researchers outline their research questions, design, method, and analysis plans before data collection and/or analysis. In this study, we aimed to empirically test the effectiveness of preregistration as a pedagogic tool in undergraduate dissertations using a quasi-experimental design. A total of 89 UK psychology students were recruited, including students who preregistered their empirical quantitative dissertation (*n* = 52; experimental group) and students who did not (*n* = 37; control group). Attitudes toward statistics, acceptance of QRPs, and perceived understanding of Open Science were measured both before and after dissertation completion. Exploratory measures included capability, opportunity, and motivation to engage with preregistration, measured at Time 1 only. This study was conducted as a Registered Report; Stage 1 protocol: https://osf.io/9hjbw (date of in-principle acceptance: September 21, 2021). Study preregistration did not significantly affect attitudes toward statistics or acceptance of QRPs. However, students who preregistered reported greater perceived understanding of Open Science concepts from Time 1 to Time 2 compared with students who did not preregister. Exploratory analyses indicated that students who preregistered reported significantly greater capability, opportunity, and motivation to preregister. Qualitative responses revealed that preregistration was perceived to improve clarity and organization of the dissertation, prevent QRPs, and promote rigor. Disadvantages and barriers included time, perceived rigidity, and need for training. These results contribute to discussions surrounding embedding Open Science principles into research training.

## Activity 4: Loading packages and reading in data

The first step is to load in the packages that we need, and read in the data


```{r eval=FALSE}
library(tidyverse)
data_prp <- read_csv("prp_data_reduced_ch1.csv")
```

```{r include=FALSE}
## I basically have to have 2 code chunks since I tell them to put the data files next to the project, and mine are in a separate folder called data - unless I'll turn this into a fixed path
library(tidyverse)
data_prp <- read_csv("data/prp_data_reduced_ch1.csv")
```

## Activity 5: Familiarise yourself with the data {#sec-familiarise}

* Look at the **Codebook** to get a feel of the variables in the dataset and how they have been measured.
* You'll notice that some questionnaire data was collected at 2 different time points (i.e., id number, gender, age, SATS28, QRPs, Understanding_OS)
* some of the data was only collected at time point 1 (i.e., the COMB) or at time point 2 (i.e., supervisor judgements, as well as OS_behav and Included_prereg variables)


Before you dive into wrangling the data, you need to get an understanding of what kind of data you are dealing with and what the format of the dataframe looks like.

As you may have noticed, `read_csv()` gives you a **message** what data types appear in your dataset and how many of the columns are in that format. It only lists a few examples of the, so it's not super useful when you want some specific information. However, it does tell you how many rows and columns your dataframe has.

But there are a few other ways you can get more detailed information about your data. Use whichever method you prefer but do it. Click on the individual tabs to look at the different options:

::: panel-tabset
## visual inspection

You can click on the blue arrow icon next to the object name in the `Global Environment`. This will expand and show information about your columns. The `$` indicates a column (from BaseR).

\[include a screenshot with a circle around the arrow\]

## glimpse()

Use `glimpse()` if you want a more detailed overview you can see on your screen. The output will display rows and column numbers, and some examples of the first couple of observations for each variable.

```{r}
glimpse(data_prp)
```

## spec()

you can also use `spec()` as suggested in the message above and then it shows you a list of the data type in every single column. But it doesn't show you the number of rows and columns.

```{r}
spec(data_prp)
```
:::

### Data types

Each variable has a **data type**, such as numeric (numbers), character (text), and logical (TRUE/FALSE values), or a special class of factor.

**Numeric data** can be double (`dbl`) or integer (`int`). Doubles can have decimal places (e.g., 1.1). Integers are the whole numbers (e.g., 1, 2, -1) and are displayed with the suffix L (e.g., 1L). This is not overly important but might leave you less puzzled the next time you see an L after a number.

**Characters** (also called “strings”) is anything written between quotation marks. This is usually text, but in special circumstances, a number can be a character if it placed within quotation marks. This can happen when you are recoding variables. It might not be too obvious at the time, but you won't be able to calculate anything if the number is a character

::: panel-tabset
## Example data types

```{r}
typeof(1)
typeof(1L)
typeof("1")
typeof("text")
```

## numeric computation

No problems here...

```{r}
1+1
```

## character computation

When the data type is incorrect, you won't be able to compute anything, despite your numbers being shown as numeric values in the dataframe. The error message tells you exactly what's wrong with it, i.e., that you have `non-numeric arguments`.

```{r, error = TRUE}
"1"+"1" # ERROR
```
:::

**Logical** data (also sometimes called “Boolean” values) are one of two values: TRUE or FALSE (written in uppercase). They become really important when we use `filter()` (see @sec-filter) or `mutate()` with conditional statements such as `case_when()` (see @sec-conditional).

Some commonly used logical operators:

| operator | description                                    |
|:---------|:-----------------------------------------------|
| \>       | greater than                                   |
| \>=      | greater than or equal to                       |
| \<       | less than                                      |
| \<=      | less than or equal to                          |
| ==       | equal to                                       |
| !=       | not equal to                                   |
| %in%     | TRUE if any element is in the following vector |

A **factor** is a specific type of integer or character that lets you assign the order of the categories. This becomes useful when you want to display certain categories in "the correct order" either in a dataframe (see *arrange*) or when plotting (see @sec-dataviz).

### Variable types

You've already encountered them in [Level 1](https://psyteachr.github.io/data-skills-v2/intro-to-probability.html){target="_blank"} but let's refresh. Variables can be classified as **continuous** (numbers) or **categorical** (labels).

**Categorical** variables are properties you can count. They can be **nominal**, where the categories don't have an order (e.g., gender) or **ordinal** (e.g., Likert scales either with numeric values 1-7 or with character labels such as "agree", "neither agree nor disagree", "disagree"). Categorical data may also be **factors** rather than characters.

**Continuous variables** are properties you can measure and calculate sums/ means/ etc. They may be rounded to the nearest whole number, but it should make sense to have a value between them. Continuous variables always have a **numeric** data type (i.e. `integer` or `double`).


::: {.callout-tip}

**Why is this important you may ask?** Knowing your variable and data types will help later on when deciding on an appropriate plot (@sec-dataviz) or which inferential test to run.

It's good to know the distinctions as it will help to decide the appropriate plot for your data (see @sec-appropriate-plot).

:::


::: {.callout-note}

## Test your understanding

Let’s have a closer look at our data `data_prp`. For this little quiz, we've selected a few columns, shortened some of the column names, and modified some of the data types. This is the first few rows of the new object `data_quiz`. *You can find the code with explanations at the end of this section*

```{r echo=FALSE}
data_quiz <- data_prp %>% 
  select(Code, Time2_Code, Age, Gender, Ethnicity, Secondyeargrade, QRP_item = QRPs_3_Time1, QRPs_mean = QRPs_Acceptance_Time1_mean) %>% 
  mutate(Gender = as.factor(Gender),
         Secondyeargrade = factor(Secondyeargrade,
                                  levels = c(1, 2, 3, 4, 5),
                                  labels = c("≥ 70% (1st class grade)", "60-69% (2:1 grade)", "50-59% (2:2 grade)", "40-49% (3rd class)", "< 40%")),
         `Code == Time2_Code` = ifelse(Code == Time2_Code, TRUE, FALSE))
```

```{r}
head(data_quiz, n = 5)
```

```{r}
glimpse(data_quiz)
```

Select from the dropdown menu the variable type and their data types for each of the columns.

```{r, include = FALSE}
# variable type
con <- c(answer = "continuous", x = "nominal", x = "ordinal")
nom <- c(x = "continuous", answer = "nominal", x = "ordinal")
ord <- c(x = "continuous", x = "nominal", answer = "ordinal")

# data type
num <- c(answer = "numeric", x = "character", x = "logical", x = "factor")
chr <- c(x = "numeric", answer = "character", x = "logical", x = "factor")
log <- c(x = "numeric", x = "character", answer = "logical", x = "factor")
fctr <- c(x = "numeric", x = "character", x = "logical", answer = "factor")

```

| Column                | Variable type | Data type     |
|:----------------------|:--------------|:--------------|
| `Age`                 | `r mcq(con)`  | `r mcq(chr)`  |
| `Gender`              | `r mcq(nom)`  | `r mcq(fctr)` |
| `Ethinicity`          | `r mcq(nom)`  | `r mcq(chr)`  |
| `Secondyeargrade`     | `r mcq(ord)`  | `r mcq(fctr)` |
| `QRP_item`            | `r mcq(ord)`  | `r mcq(num)`  |
| `QRPs_mean`           | `r mcq(con)`  | `r mcq(num)`  |
| `Code == Time2_Code`  | `r mcq(nom)`  | `r mcq(log)`  |

:::

::: {.callout-caution collapse="true"} 

## Revealing the mystery code that created `data_quiz` {.unnumbered}

```{r eval=FALSE}
data_quiz <- data_prp %>% 
  select(Code, Time2_Code, Age, Gender, Ethnicity, Secondyeargrade, QRP_item = QRPs_3_Time1, QRPs_mean = QRPs_Acceptance_Time1_mean) %>% 
  mutate(Gender = factor(Gender),
         Secondyeargrade = factor(Secondyeargrade,
                                  levels = c(1, 2, 3, 4, 5),
                                  labels = c("≥ 70% (1st class grade)", "60-69% (2:1 grade)", "50-59% (2:2 grade)", "40-49% (3rd class)", "< 40%")),
         `Code == Time2_Code` = ifelse(Code == Time2_Code, TRUE, FALSE))
```


Lets go through this line by line:

* line 1: creates a new object called `data_quiz` and it is based on the already existing data object `data_prp`
* line 2: we are selecting a few variables of interest, such as Code, Time2_Code, Age etc. Some of those variables were renamed in the process according to the structure `new_name = old_name`, for example QRP item 3 at time point 1 got renamed as `QRP_item`
* line 3: the function `mutate()` is used to create a new column called `Gender` that turns the existing column `Gender` into a factor. Now that we named the new column `Gender`, R simply overwrites the existing column of the same name. If we had named the new column `Gender_factor`, we would have been able to retain the original `Gender` column and `Gender_factor` would have been added to the end
* line 4: There are a few things going on in line 4 (or 4-6 really)
  * Note how line 3 had 2 opening brackets and only one of them was closing before the comma? This means we are still in the `mutate()` function. 
  * Now we are turning our variable `Secondyeargrade` into a factor. Spot the difference between this attempt and the one we used for `Gender`? Here we are using a lot more arguments in that factor function, namely levels and labels. **Levels** describes the unique values we have for that column, and in **labels** we want to define how these levels will be shown in the data object. If you don't add the levels and labels argument, the labels will be the labels (as you can see in the `Gender` column in which we kept the numbers)
  * And similar to `Gender`, we are replacing the "old" numeric `Secondyeargrade` with the new `Secondyeargrade` column that is now a factor
* line 7: Doesn't seem to start with a function, which means we are *still* within the `mutate()` function - count the opening and closing brackets to confirm. 
  * Here, we are creating a new column called `Code == Time2_Code`. Notice the two backticks we have to use to make this weird column name work? This is because it has spaces (and we did mention that R doesn't like spaces). So the backticks help R to group it as a unit/ a single name
  * Next we have an `ifelse()` function which is a conditional statement. We are using it to check whether a conditional statement is TRUE or FALSE. Our conditional statement asks whether the Participant IDs that were collected at time point 1 (column `Code`) are **exactly** the same as in time point 2 (column `Time2_Code`). Notice how "Tr10" and "tr10" are not considered the same. We will come back to conditional statements in @sec-wrangling. But long story short, this Boolean expression created the logical data type in the dataset.

:::




## Activity 6: 

easy data wrangling steps - counts?


## [Pair-coding in the lab]{style="color: #EBA347; text-transform: uppercase;"} {.unnumbered}

I want to produce a short knitted document that the students have to recreate including some headings, emphasis in the text, bullet points and the first steps of calculation we can do with the loneliness data with no proper data wrangling skills



## [Test your knowledge]{style="color: #EBA347; text-transform: uppercase;"} {.unnumbered}


Are you ready for some knowledge check questions to test your understanding of the chapter? We also have some faulty codes. See if you can spot what's wrong with them.


### Knowledge check {.unnumbered}

#### Question 1 {.unnumbered}

One of the key first steps when we open RStudio is to: `r longmcq(c(x = "put on some music as we will be here a while", answer = "open an existing project or create a new one", x = "make a coffee", x = "check out the news"))`

::: {.callout-caution collapse="true"} 

## Explain this answer

Opening an existing project (e.g., when coming back to the same dataset) or creating a new project (e.g., for a new task or new dataset) ensures that subsequent Rmds, any output, figures, etc are saved within the same folder on your computer (i.e., the working directory). If Rmds or data is not in the same folder as "the project icon", things can get messy and code might not run.

:::
  
#### Question 2 {.unnumbered}

When using the default environment color settings for RStudio, what color would the background of a code chunk be in R Markdown? `r mcq(c(x = "white", x = "red", x = "green", answer = "grey"))`

**Question 3**. When using the default environment color settings for RStudio, what color would the background of normal text be in R Markdown? `r mcq(c(answer = "white", x = "red", x = "green", x = "grey"))`

::: {.callout-caution collapse="true"} 

## Explain this answer

Assuming you have not changed any of the settings in RStudio, code chunks will tend to have a grey background and normal text will tend to have a white background. This is a good way to check that you have closed and opened code chunks correctly.

:::

#### Question 3 {.unnumbered}

Code chunks start and end with: `r longmcq(c(x = "three single quotes", answer = "three backticks", x = "three double quotes", x = "three single asterisks"))`

::: {.callout-caution collapse="true"} 

## Explain this answer

Code chunks always take the same general format of three backticks followed by curly parentheses and a lower case r inside the parentheses (`{r}`). People often mistake these backticks for single quotes but that will not work. If you have set your code chunk correctly using backticks, the background color should change to grey from white.

:::


### Error mode {.unnumbered}

Some of these codes have mistakes in them, other code chunks are not quite producing what was aimed for. Your task is to spot anything faulty, explain why the things happened, and perhaps try to fix them. 


#### Question 4 {.unnumbered}

You want to read in data with the `read_csv()` function. You have just stated R, created a new Rmd, and typed the following code into your code chunk.

```{r eval=FALSE}
data <- read_csv("data.csv")
```

However, R gives you an error message: `could not find function "read_csv"`. What could be the reason?

::: {.callout-caution collapse="true"} 

## Explain the solution

"Could not find function" is an indication that you have forgotten to load in tidyverse. Because `read_csv()` is a function in the tidyverse collection, R cannot find it.

FIX: Add `library(tidyverse)` prior to reading in the data and run the code chunk again.

:::


#### Question 5 {.unnumbered}

You want to read in data with the `read_csv()` function. This time, you are certain you have loaded in tidyverse first. The code is as follows:

```{r eval=FALSE}
library(tidyverse)
data <- read_csv("data.csv")
```

The error message shows `'data.csv' does not exist in current working directory`. You check your folder and it looks like this:

![](images/error_ch1_01.PNG)

Why is there an error message?

::: {.callout-caution collapse="true"} 

## Explain the solution

R is looking for a csv file that is called data which is currently not in the working directory. We may assume it's in the data folder. Perhaps that happened when unzipping the zip file. So instead of placing the csv file on the same level as the project icon, it was unzipped into a folder named data.

FIX - option 1: Take the `data.csv` out of the data folder and place it next to the project icon and the Rmd file.

FIX - option 2: Modify your R code to tell R that the data is in a separate folder called data, e.g., ...

```{r eval=FALSE}
library(tidyverse)
data <- read_csv("data/data.csv")
```


:::






